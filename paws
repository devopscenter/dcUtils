#!/usr/bin/env bash
#===============================================================================
#
#                    FILE: paws.sh
# 
#                 USAGE: ./paws.sh 
# 
#     DESCRIPTION: Provides access to AWS instances using known keys in the application
#                                utilise keys directory of the app-utils respository
# 
#             OPTIONS: ---
#    REQUIREMENTS: ---
#                    BUGS: ---
#                 NOTES: ---
#                AUTHOR: Gregg Jensen (), gjensen@devops.center
#    ORGANIZATION: devops.center
#             CREATED: 04/03/2017 11:40:09
#            REVISION:    ---
#===============================================================================

#set -o nounset                                                            # Treat unset variables as an error
#set -x

# NOTE: requires pdsh and aws-cli

PROFILE="default"

function usage
{
    echo -e "Description:"
    echo -e "    paws is a tool that makes it easier to connect to and work with AWS EC2 instances.    First, it uses the aws cli tool to query an account for running ec2-instances.    Next, it either returns a list of instances, connects to an individual instance, or runs commands on one or more of them.\n\n    Caution is advised!    (A good sanity check before running any command is using the -l option to see which hosts you're targeting).\n"
    echo -e "Usage:"
    echo -e "    Optional arguments that can be used with any other combination of arguments:"
    echo -e "    [-p PROFILE] [-r REGION]\n"
    echo -e "    List all instances, or instances and their tags:"
    echo -e "    paws {-l | -L}"
    echo -e "        -l\tno argument, returns a list of all instances"
    echo -e "        -L\tno argument, returns a list of all instances and their tags\n"
    echo -e "    Connect to a host interactively:"
    echo -e "    paws -c"
    echo -e "        -c\tno argument, displays a list of hosts and prompts for selection\n"
    echo -e "    Connect to a specified host:"
    echo -e "    paws -c HOST"
    echo -e "        -c\taws Name to log into with SSH\n"
    echo -e "    Run a command on one or more instances in parallel, using a list of names:"
    echo -e "    paws -w HOST1,HOST2 '<COMMAND>'"
    echo -e "        -w\tlist of hosts, separated by commas\n"
    echo -e "    Run a command on one or more instances in parallel, using tags:"
    echo -e "    paws -t KEY=VALUE '<COMMAND>'"
    echo -e "        -t\ttag KEY and VALUE pairs, in the form of KEY=VALUE\n"
    echo -e "    Run a command on all instances in parallel:"
    echo -e "    paws '<COMMAND>'\n"
    echo -e "    Check host access, report any failures and add any new authoritization requests"
    echo -e "    paws -p PROFILE [-r REGION} -x\n"
    echo -e "Examples:"
    echo -e "    List tags for all instances for the default account:    paws -L"
    echo -e "    Interactively connect to an instance for the client1 account in the us-west-2 region:    paws -p client1 -r us-west-2 -c"
    echo -e "    Connect to the web1 instance for the client1 account:    paws -p client1 -c web1"
    echo -e "    Run the 'hostname' command on all instances for the client1 account:    paws -p client1 'hostname'"
    echo -e "    Run the 'ls' command on the web1 and web2 instances for the client1 account:    paws -p client1 -w web1,web2 'ls'"
    echo -e "    Run the 'w' command on instances tagged as Env=dev for the client1 account:    paws -p client1 -t Env=dev 'w'"
    echo -e "    Run the 'date' command on instances tagged as Name=db1 for the default account:    paws -t Name=db1 'date'"
}

if [[ -z $1 ]]; then
    usage
    exit 1
fi

#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  getBasePath
#   DESCRIPTION:  gets the path where this file is executed from...somewhere alone the $PATH
  #    PARAMETERS:
#       RETURNS:
#-------------------------------------------------------------------------------
getBasePath()
{
    SOURCE="${BASH_SOURCE[0]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
      DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
      SOURCE="$(readlink "$SOURCE")"
      [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was   located
    done
	BASE_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
}


#-------------------------------------------------------------------------------
# handle arguments: need conditionals for appropriate number of arguments/options
#-------------------------------------------------------------------------------
doProcessDCEnv() 
{
    if [[ -z ${dcUTILS} ]]; then
        echo "Please set and export dcUTILS environment variable before starting this script"
        exit 1
    else
    set +e
        envToSource="$(${dcUTILS}/scripts/process_dc_env.py ${NEW_CMD_LINE})"

        if [[ $? -ne 0 ]]; then
            echo $envToSource
            exit 1
        else
            eval "$envToSource"
        fi
    set -e
    fi
}


#---  FUNCTION  ----------------------------------------------------------------
#          NAME:  checkHostAccess
#   DESCRIPTION:  function that will iterate through all instances found for a 
#                 given profile and try to log in.  It will print out any that 
#                 could not be reached.  If there is a new IP of the instance that
#                 needs to be added to the local authorization file it will be accepted
#                 and added.
#    PARAMETERS:  
#       RETURNS:  
#-------------------------------------------------------------------------------
checkHostAccess()
{
    if [[ ${DO_NOT_RUN} == "true" ]]; then
        echo "Would check the following hosts for access:"
        echo 

    else
        echo "Going to checking all the hosts for ssh access.  A response for each connection will be presented:"
    fi

    # first check for expect so that we can script the ssh login
    EXPECT=$(which expect)

    if [[ ! ${EXPECT} ]] ; then 
        echo "Can not run without the \'expect\' module available"
        exit 1
    fi

    NAME_LIST=$(echo $DESCRIBE_ALL| jq -r '.Reservations[].Instances[].Tags[]| select(.Key == "Name").Value')

    #-------------------------------------------------------------------------------
    # the commented out section was an attempt to check all in parallel.  It does, but
    # the ALL_OUPUT would need to be gone through and looked for specific things.  
    # This would take a lot to make it have user friendly output, when doing them in 
    # order takes just a smidgin more time but the output is WAY more friendly to work 
    # with.  Not to mention it will be easier to maintain.
    # take the list and make it a comma separated string host names
    #-------------------------------------------------------------------------------
    ##TMP_STR=""
    #for HOST_NAME in ${NAME_LIST[@]}
    #do
    #    TMP_STR="${TMP_STR}${HOST_NAME},"
    #done
    ## and the loop added one extra and it's easier to remove after the fact so here it is
    #NAME_LIST_STR=${TMP_STR/%,/}

    #THIS_DIR=$(pwd)
    #EXPECT_CMD="${EXPECT} -f $PWD/scripts/sshcmd.exp %h ${TMP_CONFIG}"
    #ALL_OUTPUT=$(PDSH_SSH_ARGS_APPEND=$(echo -F "$TMP_CONFIG") pdsh -u 30 -R exec -w "$NAME_LIST_STR" ${EXPECT} -f ${THIS_DIR}/scripts/sshcmd.exp %h ${TMP_CONFIG})

    for HOST_NAME in  ${NAME_LIST[@]}
    do
        if [[ ${DO_NOT_RUN} == "false" ]]; then
            # connect to the single host
            #ssh -oStrictHostKeyChecking=no -oCheckHostIP=no -F "$TMP_CONFIG" "$HOST"
            ${EXPECT} -f ${BASE_DIR}/scripts/sshcmd.exp ${HOST_NAME} ${TMP_CONFIG} 2>&1 > /dev/null
            if [[ $? -eq 0 ]]; then
                echo "${HOST_NAME} is good"
            else
                echo "${HOST_NAME} has a problem logging in"
            fi
        else
            # they just want to see what would happen
            echo ${HOST_NAME}
        fi
    done
    echo
}



NEW_CMD_LINE=''
APPNAME=''
WORKSPACENAME=''
DO_NOT_RUN='false'
while [[ $# -gt 0 ]]; do
    case $1 in
        -p ) shift
                PROFILE=$1
                ;;
        -r ) shift
                REGION=$1
	            ;;
        -t ) shift
                TAG=$1
                ;;
        -w ) shift
                HOSTS=$1
	            ;;
        -l ) LIST_NAMES='true'
	            ;;
        -c ) if [[ $# -eq 2 ]]; then
                shift
	            HOST=$1
	        else
	            CONNECT='true'
	        fi
                 ;;
        -L ) LIST_NAMES='true'
             LIST_ALL='true'
                 ;;
        -a | --appName) shift
             APPNAME=$1
             dcDEFAULT_APP_NAME=$1
             NEW_CMD_LINE="${NEW_CMD_LINE} --appName $APPNAME"
                 ;;
        --workspaceName) shift
             NEW_CMD_LINE="${NEW_CMD_LINE} --workspaceName $1"
                 ;;
        -e | --env) shift
             NEW_CMD_LINE="${NEW_CMD_LINE} --env $1"
                 ;;
        -x | --checkHostAccess)
             CHECK_HOST_ACCESS='true'
                 ;;
        --test )
             DO_NOT_RUN='true'
                 ;;
        -h ) usage
             exit 1
	             ;;
 [!-]* ) if [[ $# -eq 1 ]]; then
             PDSH_CMD=$1
	     elif ! [[ -z "$HOST" ]]; then
             echo -e "Too many/few of the 1 required parameters.\n"
             usage
             exit 1
         fi
                 ;;
#         * ) echo -e "Unrecognized input.\n"
#             usage
#             exit 1
    esac
    shift
done

COMMON_KEY_DIR=''
if [[ ${APPNAME} ]]; then
    doProcessDCEnv
else
    # we will be using the common key directory so we need to get the base name which is under
    # the Google Drive.  Since it could be named something else or just because it has a space in
    # the name, we need to expand it once so that we can use it below when finding the key.
    # dcCOMMON_SHARED_DIR is set when dcUtils is installed and put into the environmnet.
    aKeyValue=$(grep dcCOMMON_SHARED_DIR ~/.dcConfig/settings)
    var1=${aKeyValue#*\"}
    dcCOMMON_SHARED_DIR=${var1%\"}

    if [[ -z ${dcCOMMON_SHARED_DIR} ]]; then
        COMMON_KEY_DIR=$(cd $HOME/Googl*;pwd)
    else
        # now strip out the key and '=' to get to the path
        COMMON_KEY_DIR=${dcCOMMON_SHARED_DIR#*=}
    fi
fi

getBasePath

#-------------------------------------------------------------------------------
# check for the existance of pdsh/ssh command
#-------------------------------------------------------------------------------
if ! [[ "$LIST_NAMES" ]] && ! [[ "$CONNECT" ]] && ! [[ "$HOST" ]] && ! [[ ${CHECK_HOST_ACCESS} ]] && [[ -z "$PDSH_CMD" ]]; then
    echo -e "pdsh/ssh command required.\n"
    usage
    exit 1
fi

#-------------------------------------------------------------------------------
# get the directory of paws
# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
#-------------------------------------------------------------------------------
#SOURCE="${BASH_SOURCE[0]}"
#while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
#    SOURCE_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
#    SOURCE="$(readlink "$SOURCE")"
#    [[ $SOURCE != /* ]] && SOURCE="$SOURCE_DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
#done
#SOURCE_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
SOURCE_DIR=$HOME
#
#-------------------------------------------------------------------------------
# get full description of running instances from api and filter data using jq instead of with aws-cli
#-------------------------------------------------------------------------------
if ! [[ -z "$REGION" ]]; then
    DESCRIBE_ALL=$(${dcUTILS}/scripts/instanceinfo.py -sc listOfIPAddresses -c ${PROFILE} -r ${REGION} | jq -c 'sort_by(.InstanceName)' )
else
    DESCRIBE_ALL=$(${dcUTILS}/scripts/instanceinfo.py -sc listOfIPAddresses -c ${PROFILE}  | jq -c 'sort_by(.InstanceName)')
fi

#-------------------------------------------------------------------------------
# LIST ONLY
#-------------------------------------------------------------------------------
if [[ "$LIST_NAMES" == 'true' ]] || [[ "$CONNECT" == 'true' ]]; then

    i=0
    numItems=$(echo ${DESCRIBE_ALL} | jq -c 'length')
    while [[ ${i} -lt ${numItems} ]]; do
        #-------------------------------------------------------------------------------
        # FOR NAMES ONLY number each line to use for selection
        #-------------------------------------------------------------------------------
        hostName=$(echo ${DESCRIBE_ALL} | jq -r ".[${i}].InstanceName")
        instancePublicIP=$(echo ${DESCRIBE_ALL} | jq -r ".[${i}].PublicIpAddress")
        instancePrivateIP=$(echo ${DESCRIBE_ALL} | jq -r ".[${i}].PrivateIpAddress")
        if [[ "$LIST_ALL" != 'true' ]]; then
            if [[ -z ${instancePublicIP} ]]; then
                line="${hostName} (${instancePrivateIP})"
            else
                line="${hostName} (${instancePublicIP})"
            fi
        else
            # put all the tags in the line also
            allTags=$(echo ${DESCRIBE_ALL} | jq -c ".[${i}].Tags")
            tagsAsString=$(echo ${allTags} | jq -r "to_entries|map(select( all(. ; .key != \"Name\")))|from_entries|to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]" | tr -s '\n' ' ' )

            if [[ -z ${instancePublicIP} ]]; then
                line="Name=${hostName} PrivateIP=${instancePrivateIP} ${tagsAsString}"
            else
                line="Name=${hostName} PublicIP=${instancePublicIP} ${tagsAsString}"
            fi
        fi
        #-------------------------------------------------------------------------------
        # FOR BOTH NAMES AND ALL
        #-------------------------------------------------------------------------------
        i=$((i+1))
        NUMBERED_LINE="${i}. ${line}\n"
        NUMBERED_LIST="${NUMBERED_LIST}${NUMBERED_LINE}"
    done
fi

#-------------------------------------------------------------------------------
# for -l option, output list and exit
#-------------------------------------------------------------------------------
if [[ "$LIST_NAMES" ]]; then
    echo -en "$NUMBERED_LIST"
    exit
fi

#-------------------------------------------------------------------------------
# for -c but no host specified, so prompt for input
#-------------------------------------------------------------------------------
if [[ -z "${HOST+x}" ]] && [[ "$CONNECT" ]]; then
    echo -e "$NUMBERED_LIST"
    echo "enter selection number (return to quit)"
    read -r number

    if [[ -z ${number} || ${number} -eq 0 ]]; then
        echo "exiting "
        exit 1
    fi

    while read -r line; do
        LINE_NUMBER=$(echo "$line"|awk -F. '{print $1}')
        if [[ "$LINE_NUMBER" == "$number" ]]; then
            HOST=$(echo -e "$line"|awk '{print $2}')
        fi
    done < <(echo -e "$NUMBERED_LIST")
fi
#-------------------------------------------------------------------------------
# if no -t option
#-------------------------------------------------------------------------------
if [[ -z "$TAG" ]]; then
    #-------------------------------------------------------------------------------
    # if -c option specified, create for single instance
    #-------------------------------------------------------------------------------
    if [[ "$HOST" ]]; then
        SSH_CONFIG_VARS=($(echo -e "$DESCRIBE_ALL"| jq "[.Reservations[]|select(.Instances[]|.Tags[]|.Key == \"Name\" and .Value == \""$HOST"\")]|{Reservations: .}"|jq -c '.Reservations[]|.Instances[]|[[.Tags[]|select(.Key | contains("Name"))|.Value],.PublicIpAddress,.KeyName]'))
    else
        #-------------------------------------------------------------------------------
        # if no -c and no -t, create ssh config for all instances
        #-------------------------------------------------------------------------------
        SSH_CONFIG_VARS=($(echo "$DESCRIBE_ALL"| jq -c '.Reservations[]|.Instances[]|[[.Tags[]|select(.Key | contains("Name"))|.Value],.PublicIpAddress,.KeyName]'))
    fi

#-------------------------------------------------------------------------------
# if -t option specified, create ssh config only for tagged instances
#-------------------------------------------------------------------------------
else
    #-------------------------------------------------------------------------------
    # ensure tags are properly formatted
    #-------------------------------------------------------------------------------
    # remove any spaces between tags if there are any
    tagsNoSpaces=${TAG//[[:blank:]]/}
    # split on the , and create an array of tags:w
    TAGS=(${tagsNoSpaces//,/ })

    #-------------------------------------------------------------------------------
    # create ssh config for tagged instances
    #-------------------------------------------------------------------------------
    if [[ ${REGION} ]]; then
        CMD_TO_RUN="aws --profile "$PROFILE" --region "$REGION" ec2 describe-instances --filters Name=instance-state-name,Values=running "
    else
        CMD_TO_RUN="aws --profile "$PROFILE" ec2 describe-instances --filters Name=instance-state-name,Values=running "
    fi
    for tagLine in ${TAGS[@]}
    do
        KV=(${tagLine//=/ })
        CMD_TO_RUN+="\"Name=tag-value,Values=${KV[1]}\" "
    done
    CMD_TO_RUN+="| jq -c '.Reservations[]|.Instances[]|[[.Tags[]|select(.Key | contains(\"Name\"))|.Value],.PublicIpAddress,.KeyName]'"

    SSH_CONFIG_VARS=($(eval ${CMD_TO_RUN}))
fi

#-------------------------------------------------------------------------------
# create .ssh directory if it doesn't exist
#-------------------------------------------------------------------------------
if [[ ! -d "${SOURCE_DIR}/.ssh" ]]; then
    mkdir "${SOURCE_DIR}/.ssh"
fi

#-------------------------------------------------------------------------------
# create and populate temporary .ssh/config file
#-------------------------------------------------------------------------------
cleanUpPathList()
{
    local pathsToKey="${1}"
    retVal=$2

    numPaths=${#pathsToKey[@]}
    if [[ numPaths -ne 0 ]]; then
        retPath=""
       c=0 
       while [[ ${c} -lt ${numPaths} ]]; do
            if [[ "${pathsToKey[${c}]}" != *"Permission denied"* ]] && [[ "${pathsToKey[${c}]}" != *"find:"* ]]; then
                eval "$retVal=\"${pathsToKey[${c}]}\""
                return
            fi
            c=$(($c+1))
       done

    else
        echo "ERROR: No access key file ($keyName.pem) for this instance: $HOST could be found"
        rm -f ${TMP_CONFIG}
        exit 1
    fi
}

getPathToKey()
{
    local keyName=$1
    pathToKey=$2

    if [[ ${dcDEFAULT_APP_NAME} ]]; then
        # check the appUtils keys first
        pathsToKey=($(find ${BASE_CUSTOMER_DIR}/${dcDEFAULT_APP_NAME}/${CUSTOMER_APP_UTILS} -name "$keyName.pem"))
        numPaths=${#pathsToKey[@]}
        if [[ numPaths -ne 0 ]]; then
            RETVAL=''
            cleanUpPathList "${pathsToKey[@]}" RETVAL
            eval "$pathToKey=\"${RETVAL}\""
        else
            # not there so lets check the pool
            pathsToKey="$(find ${COMMON_KEY_DIR} -path "*/devops.center/keys/${keyName}.pem" 2>&1)"
            RETVAL=''
            cleanUpPathList "${pathsToKey[@]}" RETVAL
            eval "$pathToKey=\"${RETVAL}\""
        fi
    else
        DC_COMMON_KEY_DIR=${COMMON_KEY_DIR%/*}
        if [[ -f "${DC_COMMON_KEY_DIR}/${PROFILE}/devops.center/keys/${keyName}.pem" ]]; then
            RETVAL="${DC_COMMON_KEY_DIR}/${PROFILE}/devops.center/keys/${keyName}.pem"
        elif [[ -f "${COMMON_KEY_DIR}/devops.center/keys/${keyName}.pem" ]]; then
            RETVAL="${COMMON_KEY_DIR}/devops.center/keys/${keyName}.pem"
        elif [[ -f "${COMMON_KEY_DIR}/${PROFILE}/devops.center/keys/${keyName}.pem" ]]; then
            RETVAL="${COMMON_KEY_DIR}/${PROFILE}/devops.center/keys/${keyName}.pem"
        else
            RETVAL="${COMMON_KEY_DIR}/${PROFILE}/keys/${keyName}.pem"
        fi
        eval "$pathToKey=\"${RETVAL}\""
    fi
}

TMP_CONFIG=$(mktemp "${HOME}"/.ssh/.config.XXXXX)
numSSH_CONFIG="${#SSH_CONFIG_VARS[@]}"
q=0
declare -a NEW_SSH_CONFIG_VARS
while [[ $q -lt ${numSSH_CONFIG} ]]; do
    ITEMLIST=()
    ITEMSTRING=''
    ITEMSTRING=$(echo "${SSH_CONFIG_VARS[${q}]}"|tr -d ']["')
    IFS=$','; ITEMLIST=($ITEMSTRING); unset IFS;
    numItems=${#ITEMLIST[@]}
    if [[ $numItems -gt 2 ]]; then
        if [[ ${ITEMLIST[2]} =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]];then
            q=$(($q+1))
            continue
        fi
        pathToKey=''
        getPathToKey ${ITEMLIST[2]} pathToKey
        NEW_SSH_CONFIG_VARS+=("${ITEMLIST[0]},${ITEMLIST[1]},${pathToKey}")
    fi
    q=$(($q+1))
done

for theItem in "${NEW_SSH_CONFIG_VARS[@]}"
do
    IFS=$','; configItemList=($theItem); unset IFS;
    echo "Host ${configItemList[0]}" >> $TMP_CONFIG
    echo " hostname ${configItemList[1]}" >> $TMP_CONFIG
    echo " identityfile \"${configItemList[2]}\"" >> $TMP_CONFIG
    echo " user ubuntu" >> $TMP_CONFIG
    echo >> $TMP_CONFIG
done

#-------------------------------------------------------------------------------
# if the -c option is specified, connect to the host with ssh
#-------------------------------------------------------------------------------
if [[ "$HOST" ]] || [[ ${CHECK_HOST_ACCESS} == 'true' ]]; then
    if [[ ${CHECK_HOST_ACCESS} == 'true' ]]; then
        # run the function that will itereate over all the hosts
        checkHostAccess
    else
        # connect to the single host
        ssh -F "$TMP_CONFIG" "$HOST"
    fi
#-------------------------------------------------------------------------------
# otherwise, run commands with pdsh
#-------------------------------------------------------------------------------
else
    if ! [[ "$HOSTS" ]]; then
        #-------------------------------------------------------------------------------
        # generate host list to pass pdsh
        #-------------------------------------------------------------------------------
        HOSTS=$(grep Host "$TMP_CONFIG"|awk '{print $2}'|tr '\n' ',')
    fi
    #-------------------------------------------------------------------------------
    # final pdsh command
    #-------------------------------------------------------------------------------
    if [[ ${DO_NOT_RUN} == 'false' ]]; then
        # go ahead and run it

        PDSH_OUTPUT=$(PDSH_SSH_ARGS_APPEND=$(echo -F "$TMP_CONFIG") pdsh -u 30 -w "$HOSTS" "$PDSH_CMD" 2>&1)
        IFS=$'\n'; PDSH_OUTPUT_LIST=(${PDSH_OUTPUT}); unset IFS
        for aLine in "${PDSH_OUTPUT_LIST[@]}"; do
            if [[ "${aLine}" == *"Operation timed out"* ]]; then
                THE_BAD_HOST=${aLine%%:*}
                echo "CRITICAL: This host could not be reached: ${THE_BAD_HOST}"
            elif [[ "${aLine}" != *"ssh exited with exit code"* ]]; then
                echo "${aLine}"
            fi
        done

    else
        # they just want to see what would happen
        echo 
        echo "Test would run command: $PDSH_CMD"
        echo
        echo "For these hosts:"
        for aHost in ${HOSTS//,/ }
        do
            echo ${aHost}
        done
        echo 

    fi
fi

#-------------------------------------------------------------------------------
# remove temporary .ssh/config file
#-------------------------------------------------------------------------------
 if [[ -f "$TMP_CONFIG" ]]; then
     rm "$TMP_CONFIG"
 fi
